=head1 NAME

Net::Webdav - Perl interface to Neon HTTP and WebDAV client library

=head1 SYNOPSIS

  use Net::Webdav ;

  $sess = Net::Webdav -> new ;
  $sess -> server ("www.ecos.de", 80) ;
  $sess -> get ("/", STDOUT) ;

  $sess -> put ("/dav/foo.htm", STDIN) ;

  # remove property 'test3'
  # set value of property 'test' to 'bar'
  @props = (
    { name => {nspace => 'DAV:', name => 'test3'}, type => 1},
    { name => {nspace => 'DAV:', name => 'test'}, value => 'bar'},
    ) ;

  $sess -> dav_proppatch ("/dav/foo.htm", \@props) ;


  sub iterator
    {
    my ($userdata, $propname, $propvalue, $propstatus) = @_ ;

    print "propfind userdata = $userdata  nspace = $propname->{nspace}  name = $propname->{name}  value = $propvalue\n" ;
    
    return 0 ;
    }

  sub callback
    {
    my ($userdata, $href, $results) = @_ ;

    print "propfind callback userdata = $userdata  href = $href\n" ;

    $results -> iterate (\&iterator) ;
    }

  $sess -> dav_simple_propfind ("/dav", DAV_DEPTH_ONE, undef, \&callback) ;

  print "Status: ", $sess -> get_error , "\n" ;



=head1 DESCRIPTION


This is the Perl interface to the neon HTTP and WebDAV client library.
Most of the documentation is automaticly generated from the C header
files of neon. So it looks a little bit C-ish, but is better than
nothing. See also the examples in the B<eg> directory. 
If you not sure how it works consult the neon include files.

This document describes the function that are availabe. Net::Webdav::Constants
includes the constants defined by neon.

The neon API is encapsultated in a number of Perl classes. Everything that 
doesn't fit in a class has gone to Net::Webdav::Util. (Maybe some of these
function will move to other classes in the future)

The clases are

=over 4

=item Net::Webdav

Main class which holds a http session

=item Net::Webdav::MultiStatus

Class to handle 207 responses

=item Net::Webdav::Hip

Interface to XML parser for properties

=item Net::Webdav::Lock

Holds a lock

=item Net::Webdav::LockSession

Holds a lock session

=item Net::Webdav::Propfind

Class to access the result of a PROPFIND

=item Net::Webdav::Propset

Class to acess properties of one resource

=item Net::Webdav::Request

Low level interface to http request

=item Net::Webdav::MD5

MD5 checksum

=item Net::Webdav::SSL

SSL support

=item Net::Webdav::Socket

Low level socket access

=back


WARNING: This wrapper is alpha code, while neon is around for some time and
stable to use, not all of the interface functions provided by this Perl module
has been tested extensivly, but most of them should work without problems (At least
they do it for me :-).


See in the eg directory for some examples.


=head1 CALLBACKS

Neon uses a lot off callbacks. Basicly there is no difference between using callbacks
in Perl and C. The only thing that is different, is that the functions that sets the
callbacks doesn't take the C<userdata> argument, which is used in C to pass a pointer
to the callback. Instead, the callback get the reference to the object that sets
the callback, pass as the userdata argument. This object is a hashreference and you
are free to store data in that hash. The only restriction is, that key starting
with two underscores ('__') are reserved for Net::Webdav internal use. Example:


  sub datehdr

    {
    my ($userdata, $value) = @_ ;
    $userdata -> {date} = $value ;
    } 

  $sess = Net::Webdav -> new ;
  $sess -> server ("www.ecos.de", 80) ;
  $request = $sess -> request_create ("HEAD", "/") ;
  # install callback which gets only Date header
  $request -> add_response_header_handler ('Date', \&datehdr) ;
  $request -> begin_request ;
  $request -> end_request ;
  
  print "Date: $request->{date}\n" ;

=head1 C-DATASTRUCTURS

The C-structures that neon uses are always mapped 1:1 into a Perl hash. The members
of the Perl hash are shown in the argument list of the function between { and }
The function argument lists, also list the C datatype to which it map, so you can
checkout the neon docs and include files for more informations.







=head1 Functions




=head1 Methods of Net::Webdav

=head2 $session -> add_hooks (hooks,free_cookie)

Add in hooks.
'cookie' will be passed to each call to the 'create' handler of the hooks.
If 'free_hooks' is non-NULL, it will called when the session is destroyed,
to free any data associated with 'cookie'.


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item hooks

const http_request_hooks *





=item Callback function: free_cookie

free_cookie (cookie)




=over 4

=item cookie

void *



=back



=back


=back

=head2 int = $session -> dav_copy (overwrite,src,dest)

Basic WebDAV methods:
dav_copy:  copy resoure from src to dest
dav_move:  move resource from src to dest
-> if overwrite is non-zero, the destination resource
will be overwritten if it exists.
dav_delete: delete resource at uri
dav_mkcol: create a collection at uri (uri MUST have a trailing slash).


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item overwrite

<integer>


=item src

<string>


=item dest

<string>




=back


=back

=head2 int = $session -> dav_delete (uri)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>




=back


=back

=head2 int = $session -> dav_lock ($davlock)

Issue a LOCK request for the given lock. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item $davlock

struct dav_lock *




=back


=back

=head2 int = $session -> dav_lock_discover (uri,result)

Perform lock discovery on the given URI.  'result' is called
with the results (possibly >1 times).  

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>




=item Callback function: result

result (userdata,$davlock,uri,status)

Callback for lock discovery.  If 'lock' is NULL, 
something went wrong retrieving lockdiscover for the resource,
look at 'status' for the details. 



=over 4

=item userdata

void *

=item lock

const struct dav_lock *

=item uri

<string>

=item status

const http_status *



=back



=back


=back

=head2 $davlocksession = $session -> dav_lock_register ()

Register the locking hooks with an http_session.  Owned locks
persist for the duration of this session. The lock session lasts
exactly as long as the corresponding http_session. Once you call
http_session_destroy(sess), any use of the lock session has
undefined results.  

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back

=head2 int = $session -> dav_mkcol (uri)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>




=back


=back

=head2 int = $session -> dav_move (overwrite,src,dest)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item overwrite

<integer>


=item src

<string>


=item dest

<string>




=back


=back

=head2 $propfind = $session -> dav_propfind_create (uri,depth)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item depth

<integer>




=back


=back

=head2 int = $session -> dav_propnames (href,depth,results)

Retrieve property names for the resources at 'href'.  'results'
callback is called for each resource.  Use 'dav_propset_iterate' on
the passed results object to retrieve the list of property names.  

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item href

<string>


=item depth

<integer>




=item Callback function: results

results (userdata,href,$propset)

Callback for handling the results of fetching properties for a
single resource (named by 'href').  The results are stored in the
result set 'results': use dav_propset_* to examine this object.  



=over 4

=item userdata

void *

=item href

<string>

=item results

const dav_prop_result_set *



=back



=back


=back

=head2 int = $session -> dav_proppatch (uri,items)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item items

const dav_proppatch_operation *




items = {
name => const dav_propname *, type => enum, value => <string>, };





=back


=back

=head2 int = $session -> dav_simple_propfind (uri,depth,props,results)

Fetch properties for a resource (if depth == DAV_DEPTH_ZERO),
or a tree of resources (if depth == DAV_DEPTH_ONE or _INFINITE).

Names of the properties required must be given in 'props',
or if props is NULL, *all* properties are fetched.

'results' is called for each resource in the response, userdata is
passed as the first argument to the callback. It is important to
note that the callback is called as the response is read off the
socket, so don't do anything silly in it (e.g. sleep(100), or call
any functions which use this session).

Note that if 'depth' is DAV_DEPTH_INFINITY, some servers may refuse
the request.

Returns HTTP_*.  

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item depth

<integer>


=item props

const dav_propname *




props = {
nspace => <string>, name => <string>, };





=item Callback function: results

results (userdata,href,$propset)

Callback for handling the results of fetching properties for a
single resource (named by 'href').  The results are stored in the
result set 'results': use dav_propset_* to examine this object.  



=over 4

=item userdata

void *

=item href

<string>

=item results

const dav_prop_result_set *



=back



=back


=back

=head2 int = $session -> dav_simple_request ($request)

Handle a simple WebDAV request.

Usage:
1. Create the request using http_request_create()
2. Set any headers, the request body, whatever.
3. Call dav_simple_request to dispatch and destroy the request.

(note the request IS destroyed by this function, don't do it 
yourself).

Returns HTTP_* as http_request_dispatch() would. If the response is
a 207, a user-friendly error message is written to the session
error buffer; e.g.  DELETE /foo/ might give the error:
/foo/bar: HTTP/1.1 423 Locked


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item $request

http_req *





=back


=back

=head2 int = $session -> dav_unlock ($davlock)

Issue an UNLOCK request for the given lock 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item $davlock

struct dav_lock *




=back


=back

=head2 $session -> decide_proxy (use_proxy)

Register the callback for determining whether the proxy server
should be used or not here.  'userdata' will be passed as the first
argument to the callback. The callback is only called if a proxy
server has been set up using http_session_proxy. 

This function MUST be called before calling http_session_server.


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=item Callback function: use_proxy

int = use_proxy (userdata,scheme,hostname)

Callback to determine whether the proxy server should be used or
not for a request to the given hostname using the given scheme.
Scheme will be "http" or "https" etc.
Must return:
Zero to indicate the proxy should NOT be used
Non-zero to indicate the proxy SHOULD be used.




=over 4

=item userdata

void *

=item scheme

<string>

=item hostname

<string>



=back



=back


=back

=head2 int = $session -> destroy ()

Finish an HTTP session 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back

=head2 $session -> forget_auth ()

Clear any stored authentication details for the given session. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back

=head2 int = $session -> get (uri,f)

GET resource at uri, writing response body into f 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item f

<filehandle>





=back


=back

=head2 const char * = $session -> get_error ()


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back

=head2 int = $session -> get_range (uri,range,f)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item range

http_content_range *




range = {
start => <integer>, end => <integer>, total => <integer>, };



=item f

<filehandle>





=back


=back

=head2 const char * = $session -> get_scheme ()

Returns the URL scheme being used for the current session.
Does NOT include a trailing ':'. 
Example returns: "http" or "https".


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back

=head2 const char * = $session -> get_server_hostport ()

Returns the 'hostport' URI segment for the end-server, e.g.
"my.server.com:8080"    or    "www.server.com" 
(port segment is ommitted if == 80) 


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back

=head2 int = $session -> getmodtime (uri,modtime)

Retrieve modification time of resource at uri, place in *modtime.
(uses HEAD) 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item modtime

time_t *





=back


=back

=head2 void * = $session -> hook_private (id)

Return private data for the session 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item id

<string>




=back


=back

=head2 int = $session -> options (uri,caps)

Determines server capabilities (using OPTIONS). 
Pass uri="*" to determine proxy server capabilities if using
a proxy server. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item caps

http_server_capabilities *




caps = {
 => , dav_class1 => unsigned int, dav_class2 => unsigned int, dav_executable => unsigned int, };





=back


=back

=head2 int = $session -> post (uri,f,buffer)

Post using buffer as request-body: stream response into f 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item f

<filehandle>



=item buffer

<string>




=back


=back

=head2 int = $session -> proxy (hostname,port)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item hostname

<string>


=item port

<integer>




=back


=back

=head2 int = $session -> put (uri,f)

PUT resource at uri, reading request body from f 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item f

<filehandle>





=back


=back

=head2 int = $session -> put_if_unmodified (uri,stream,modtime)

PUT resource at uri as above, only if it has not been modified
since given modtime. If server is HTTP/1.1, uses If-Unmodified-Since
header; guaranteed failure if resource is modified after 'modtime'.
If server is HTTP/1.0, HEAD's the resource first to fetch current
modtime; race condition if resource is modified between HEAD and PUT.


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>


=item stream

<filehandle>



=item modtime

time_t





=back


=back

=head2 int = $session -> read_file (uri,reader)

GET resource at uri, passing response body blocks to 'reader' 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item uri

<string>




=item Callback function: reader

reader (userdata,buf,len)

The 'reader' callback type 



=over 4

=item userdata

void *

=item buf

<string>

=item len

size_t



=back



=back


=back

=head2 const char * = $session -> redirect_location ()

Return location of last redirect. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back

=head2 $session -> redirect_register (confirm,notify)

Register redirect handling for the given session.
Some redirect responses will be automatically followed.
If the redirect is automatically followed, the 'notify' callback
is called.
For redirects which are NOT automatically followed, the
'confirm' callback is called: if this returns zero, the redirect
is ignored.

'confirm' may be passed as NULL: in this case, only automatic
redirects are followed.  'notify' may also be passed as NULL,
automatic redirects are still followed.

'userdata' is passed as the first argument to the confirm and
notify callbacks.  

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=item Callback function: confirm

int = confirm (userdata,src,dest)

Get confirmation from the user that a redirect from
URI 'src' to URI 'dest' is acceptable. Should return:
Non-Zero to FOLLOW the redirect
Zero to NOT follow the redirect




=over 4

=item userdata

void *

=item src

<string>

=item dest

<string>



=back



=item Callback function: notify

notify (userdata,src,dest)

Notify the user that a redirect has been automatically 
followed from URI 'src' to URI 'dest' 



=over 4

=item userdata

void *

=item src

<string>

=item dest

<string>



=back



=back


=back

=head2 $request = $session -> request_create (method,uri)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item method

<string>


=item uri

<string>




=back


=back

=head2 int = $session -> server (hostname,port)

Set the server or proxy server to be used for the session.
Returns:
HTTP_LOOKUP if the DNS lookup for hostname failed.
HTTP_OK otherwise.

Note that if a proxy is being used, http_session_proxy should be
called BEFORE http_session_server, so the DNS lookup can be skipped
on the server. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item hostname

<string>


=item port

<integer>




=back


=back

=head2 int = $session -> set_accept_secure_upgrade (acc_upgrade)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item acc_upgrade

<integer>




=back


=back

=head2 $session -> set_error (errstring)

Set the error string for the session 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item errstring

<string>




=back


=back

=head2 $session -> set_expect100 (use_expect100)

Set protocol options for session:
expect100: Defaults to OFF
persist:   Defaults to ON

expect100: When set, send the "Expect: 100-continue" request header
with requests with bodies.

persist: When set, use a persistent connection. (Generally,
you don't want to turn this off.)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item use_expect100

<integer>




=back


=back

=head2 $session -> set_persist (persist)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item persist

<integer>




=back


=back

=head2 $session -> set_progress (progress)

Set a progress callback for the session. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=item Callback function: progress

progress (userdata,progress,total)




=over 4

=item userdata

void *

=item progress

<integer>

=item total

<integer>



=back



=back


=back

=head2 $session -> set_proxy_auth (callback)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=item Callback function: callback

int = callback (userdata,realm,username,password)

The callback used to request the username and password in the given
realm. The username and password must be placed in malloc()-allocated
memory.
Must return:
0 on success: *username and *password must be non-NULL, and will
be free'd by the HTTP layer when necessary
-1 to cancel (*username and *password are ignored.)




=over 4

=item userdata

void *

=item realm

<string>

=item username

char **

=item password

char **



=back



=back


=back

=head2 int = $session -> set_request_secure_upgrade (req_upgrade)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item req_upgrade

<integer>




=back


=back

=head2 int = $session -> set_secure (secure)


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item secure

<integer>




=back


=back

=head2 $session -> set_secure_context ($ssl)

Using SSL/TLS connections:

Session settings:
secure:                 Defaults to OFF
secure_context:         No callbacks, any protocol allowed.
request_secure_upgrade: Defaults to OFF
accept_secure_ugprade:  Defaults to OFF

secure_context: When set, specifies the settings to use for secure
connections, and any callbacks (see nsocket.h).  The lifetime of
the context object must be >= to the lifetime of the session
object.

secure: When set, use a secure (SSL/TLS) connection to the origin
server. This will tunnel (using CONNECT) through the proxy server
if one is being used.

request_secure_upgrade: When set, notify the server with each
request made that an upgrade to a secure connection is desired, if
available.

accept_secure_upgrade: When set, allow a server-requested upgrade
to a secure connection.

NB: the latter three function calls will return -1 if SSL is not
supported by the library (i.e., it was not built against OpenSSL),
or 0 if it is.


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item $ssl

nssl_context *





=back


=back

=head2 $session -> set_server_auth (callback)

Set callbacks to handle server and proxy authentication.
userdata is passed as the first argument to the callback. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=item Callback function: callback

int = callback (userdata,realm,username,password)

The callback used to request the username and password in the given
realm. The username and password must be placed in malloc()-allocated
memory.
Must return:
0 on success: *username and *password must be non-NULL, and will
be free'd by the HTTP layer when necessary
-1 to cancel (*username and *password are ignored.)




=over 4

=item userdata

void *

=item realm

<string>

=item username

char **

=item password

char **



=back



=back


=back

=head2 $session -> set_status (status)

Set a status notification callback for the session, to report
connection status. 

=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=item Callback function: status

status (userdata,status,info)




=over 4

=item userdata

void *

=item status

http_conn_status

=item info

<string>



=back



=back


=back

=head2 $session -> set_useragent (product)

Sets the user-agent string. neon/VERSION will be appended, to make
the full header "User-Agent: product neon/VERSION".
If this function is not called, the User-Agent header is not sent.
The product string must follow the RFC2616 format, i.e.
product         = token ["/" product-version]
product-version = token
where token is any alpha-numeric-y string [a-zA-Z0-9]*


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****


=item product

<string>




=back


=back

=head2 int = $session -> version_pre_http11 ()

Determine if next-hop server claims HTTP/1.1 compliance. Returns:
0 if next-hop server does NOT claim HTTP/1.1 compliance
non-zero if next-hop server DOES claim HTTP/1.1 compliance
Not that the "next-hop" server is the proxy server if one is being
used, otherwise, the origin server.


=over 4

=item Arguments

=over 4

=item $session

http_session *

**** Session Handling *****




=back


=back



=head1 Methods of Net::Webdav::Hip

=head2 $multstatus = $hip -> dav_207_create ()

Create a 207 parser 

=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *





=back


=back

=head2 int = $hip -> xml_currentline ()

Return current parse line for errors 

=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *





=back


=back

=head2 $hip -> xml_destroy ()

Destroys the parser. Any operations on it then have 
undefined results. 

=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *





=back


=back

=head2 const char * = $hip -> xml_get_error ()


=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *





=back


=back

=head2 $hip -> xml_parse (block,len)

Parse the given block of input of length len. Block does 
not need to be NULL-terminated. 

=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *



=item block

<string>


=item len

size_t





=back


=back

=head2 $hip -> xml_push_handler (elements,validate_cb,startelm_cb,endelm_cb)

Push a handler onto the handler stack for the given list of elements.
elements must be an array, with the last element .nspace being NULL.
Callbacks are called in order:
1. validate_cb
2. startelm_cb
3. endelm_cb
(then back to the beginning again).
If any of the callbacks ever return non-zero, the parse will STOP.
userdata is passed as the first argument to startelm_cb and endelm_cb.


=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *



=item elements

const struct hip_xml_elm *


=item validate_cb

hip_xml_validate_cb

Validate a new child element. 




=item Callback function: startelm_cb

int = startelm_cb (userdata,elm,atts)




=over 4

=item userdata

void *

=item elm

const struct hip_xml_elm *

=item atts

const char **



=back



=item Callback function: endelm_cb

int = endelm_cb (userdata,s,cdata)

Called when a complete element is parsed 



=over 4

=item userdata

void *

=item s

const struct hip_xml_elm *

=item cdata

<string>



=back



=back


=back

=head2 $hip -> xml_push_mixed_handler (elements,validate_cb,startelm_cb,cdata_cb,endelm_cb)

Add a handler which uses a mixed-mode cdata callback 

=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *



=item elements

const struct hip_xml_elm *


=item validate_cb

hip_xml_validate_cb

Validate a new child element. 




=item Callback function: startelm_cb

int = startelm_cb (userdata,elm,atts)




=over 4

=item userdata

void *

=item elm

const struct hip_xml_elm *

=item atts

const char **



=back



=item Callback function: cdata_cb

cdata_cb (userdata,s,cdata,len)




=over 4

=item userdata

void *

=item s

const struct hip_xml_elm *

=item cdata

<string>

=item len

<integer>



=back



=item Callback function: endelm_cb

int = endelm_cb (userdata,s,cdata)

Called when a complete element is parsed 



=over 4

=item userdata

void *

=item s

const struct hip_xml_elm *

=item cdata

<string>



=back



=back


=back

=head2 $hip -> xml_set_error (msg)

Set error message for parser 

=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *



=item msg

<string>




=back


=back

=head2 int = $hip -> xml_valid ()

Returns non-zero if the parse was valid, zero if it failed (e.g.,
any of the callbacks return non-zero, the XML was not well-formed,
etc).  Use hip_xml_get_error to retrieve the error message if it
failed. 

=over 4

=item Arguments

=over 4

=item $hip

hip_xml_parser *





=back


=back



=head1 Methods of Net::Webdav::Lock

=head2 $davlock = $davlock -> copy ()

Deep-copy a lock structure. 

=over 4

=item Arguments

=over 4

=item $davlock

const struct dav_lock *




=back


=back

=head2 $davlock -> free ()

Free a lock structure 

=over 4

=item Arguments

=over 4

=item $davlock

struct dav_lock *




=back


=back



=head1 Methods of Net::Webdav::LockSession

=head2 $davlocksession -> add ($davlock)

Add a lock to the given session. The lock will subsequently be
submitted as required in an If: header with any requests created
using the http_session which the lock session is tied to.  Requests
indicate to the locking layer which locks they might need using
dav_lock_using_*, as described below. 

=over 4

=item Arguments

=over 4

=item $davlocksession

dav_lock_session *



=item $davlock

struct dav_lock *




=back


=back

=head2 $davlock = $davlocksession -> find (uri)

Find a lock in the session with given URI 

=over 4

=item Arguments

=over 4

=item $davlocksession

dav_lock_session *



=item uri

<string>




=back


=back

=head2 int = $davlocksession -> iterate (func)

For each lock added to the session, call func, passing the lock
and the given userdata. Returns the number of locks. func may be
pass as NULL, in which case, can be used to simply return number
of locks in the session. 

=over 4

=item Arguments

=over 4

=item $davlocksession

dav_lock_session *





=item Callback function: func

func ($davlock,userdata)




=over 4

=item lock

struct dav_lock *

=item userdata

void *



=back



=back


=back

=head2 $davlocksession -> remove ($davlock)

Remove lock, which must have been previously added to the
session using 'dav_lock_add' above. 

=over 4

=item Arguments

=over 4

=item $davlocksession

dav_lock_session *



=item $davlock

struct dav_lock *




=back


=back



=head1 Methods of Net::Webdav::MD5

=head2 void * = $md5ctx -> finish_ctx (resbuf)


=over 4

=item Arguments

=over 4

=item $md5ctx

struct ne_md5_ctx *


=item resbuf

void *




=back


=back

=head2 $md5ctx -> init_ctx ()


=over 4

=item Arguments

=over 4

=item $md5ctx

struct ne_md5_ctx *




=back


=back



=head1 Methods of Net::Webdav::MultiStatus

=head2 $multstatus -> destroy ()


=over 4

=item Arguments

=over 4

=item $multstatus

dav_207_parser *





=back


=back

=head2 void * = $multstatus -> get_current_propstat ()


=over 4

=item Arguments

=over 4

=item $multstatus

dav_207_parser *





=back


=back

=head2 void * = $multstatus -> get_current_response ()


=over 4

=item Arguments

=over 4

=item $multstatus

dav_207_parser *





=back


=back

=head2 $multstatus -> ignore_unknown ()

Call this as the LAST thing before beginning parsing, to install a
catch-all handler which means all unknown XML returned in the 207
response is ignored gracefully.  

=over 4

=item Arguments

=over 4

=item $multstatus

dav_207_parser *





=back


=back

=head2 $multstatus -> set_propstat_handlers (start,end)


=over 4

=item Arguments

=over 4

=item $multstatus

dav_207_parser *



=item start

dav_207_start_propstat





=item Callback function: end

end (userdata,propstat,status_line,status,description)




=over 4

=item userdata

void *

=item propstat

void *

=item status_line

<string>

=item status

const http_status *

=item description

<string>



=back



=back


=back

=head2 $multstatus -> set_response_handlers (start,end)

Set the callbacks for the parser 

=over 4

=item Arguments

=over 4

=item $multstatus

dav_207_parser *



=item start

dav_207_start_response

TODO: do we need to pass userdata to ALL of these? We could get away with
only passing the userdata to the start_'s and relying on the caller
to send it through as the _start return value if they need it. 




=item Callback function: end

end (userdata,response,status_line,status,description)




=over 4

=item userdata

void *

=item response

void *

=item status_line

<string>

=item status

const http_status *

=item description

<string>



=back



=back


=back



=head1 Methods of Net::Webdav::Propfind

=head2 int = $propfind -> allprop (result)

Find all properties.

Returns HTTP_*. 

=over 4

=item Arguments

=over 4

=item $propfind

dav_propfind_handler *





=item Callback function: result

result (userdata,href,$propset)

Callback for handling the results of fetching properties for a
single resource (named by 'href').  The results are stored in the
result set 'results': use dav_propset_* to examine this object.  



=over 4

=item userdata

void *

=item href

<string>

=item results

const dav_prop_result_set *



=back



=back


=back

=head2 void * = $propfind -> current_private ()

Retrieve the 'private' pointer for the current propset for the
given handler, as returned by the dav_props_create_complex callback
installed using 'dav_propfind_set_private'.  If this callback was
not registered, this function will return NULL.  

=over 4

=item Arguments

=over 4

=item $propfind

dav_propfind_handler *





=back


=back

=head2 $propfind -> destroy ()

Destroy a propfind handler after use. 

=over 4

=item Arguments

=over 4

=item $propfind

dav_propfind_handler *





=back


=back

=head2 $hip = $propfind -> get_parser ()

Return the XML parser for the given handler (only need if you want
to handle complex properties). 

=over 4

=item Arguments

=over 4

=item $propfind

dav_propfind_handler *





=back


=back

=head2 $request = $propfind -> get_request ()

Return the request object for the given handler.  You MUST NOT use
http_set_request_body_* on this request object.  (this call is only
needed if for instance, you want to add extra headers to the
PROPFIND request).  

=over 4

=item Arguments

=over 4

=item $propfind

dav_propfind_handler *





=back


=back

=head2 int = $propfind -> named (prop,result)

Find properties named in a call to dav_propfind_set_flat and/or
dav_propfind_set_complex.

Returns HTTP_*. 

=over 4

=item Arguments

=over 4

=item $propfind

dav_propfind_handler *



=item prop

const dav_propname *




prop = {
nspace => <string>, name => <string>, };





=item Callback function: result

result (userdata,href,$propset)

Callback for handling the results of fetching properties for a
single resource (named by 'href').  The results are stored in the
result set 'results': use dav_propset_* to examine this object.  



=over 4

=item userdata

void *

=item href

<string>

=item results

const dav_prop_result_set *



=back



=back


=back

=head2 $propfind -> set_private (creator,userdata)


=over 4

=item Arguments

=over 4

=item $propfind

dav_propfind_handler *



=item creator

dav_props_create_complex

A "complex property" has a value which is structured XML. To handle
complex properties, you must set up and register an XML handler
which will understand the elements which make up such properties.
The handler must be registered with the parser returned by
'dav_propfind_get_parser'.

To store the parsed value of the property, a 'private' structure is
allocated in each propset (i.e. one per resource). When parsing the
property value elements, for each new resource encountered in the
response, the 'creator' callback is called to retrieve a 'private'
structure for this resource.

Whilst in XML element callbacks you will have registered to handle
complex properties, you can use the 'dav_propfind_current_private'
call to retrieve the pointer to this private structure.

To retrieve this 'private' structure from the propset in the
results callback, simply call 'dav_propset_private'.



=item userdata

void *




=back


=back



=head1 Methods of Net::Webdav::Propset

=head2 int = $propset -> iterate (iterator)

Iterate over all the properties in 'set', calling 'iterator'
for each, passing 'userdata' as the first argument to callback.

Returns:
whatever value iterator returns.


=over 4

=item Arguments

=over 4

=item $propset

const dav_prop_result_set *

The 'dav_simple_propfind' interface. ***

dav_simple_propfind allows you to fetch a set of properties for a
single resource, or a tree of resources.  You set the operation
going by passing these arguments:

- the session which should be used.
- the URI and the depth of the operation (0, 1, infinite)
- the names of the properties which you want to fetch
- a results callback, and the userdata for the callback.

For each resource found, the results callback is called, passing
you two things along with the userdata you passed in originally:

- the URI of the resource (const char *href)
- the properties results set (const dav_prop_result_set *results)





=item Callback function: iterator

int = iterator (userdata,pname,value,status)

dav_propset_iterate iterates over a properties result set,
calling the callback for each property in the set. userdata is
passed as the first argument to the callback. value may be NULL,
indicating an error occurred fetching this property: look at 
status for the error in that case.

If the iterator returns non-zero, dav_propset_iterate will return
immediately with that value.




=over 4

=item userdata

void *

=item pname

const dav_propname *

=item value

<string>

=item status

const http_status *



=back



=back


=back

=head2 const char * = $propset -> lang (pname)

Return language string of property (may be NULL). 

=over 4

=item Arguments

=over 4

=item $propset

const dav_prop_result_set *

The 'dav_simple_propfind' interface. ***

dav_simple_propfind allows you to fetch a set of properties for a
single resource, or a tree of resources.  You set the operation
going by passing these arguments:

- the session which should be used.
- the URI and the depth of the operation (0, 1, infinite)
- the names of the properties which you want to fetch
- a results callback, and the userdata for the callback.

For each resource found, the results callback is called, passing
you two things along with the userdata you passed in originally:

- the URI of the resource (const char *href)
- the properties results set (const dav_prop_result_set *results)



=item pname

const dav_propname *




pname = {
nspace => <string>, name => <string>, };





=back


=back

=head2 void * = $propset -> private ()

Returns the private pointer for the given propset. 

=over 4

=item Arguments

=over 4

=item $propset

const dav_prop_result_set *

The 'dav_simple_propfind' interface. ***

dav_simple_propfind allows you to fetch a set of properties for a
single resource, or a tree of resources.  You set the operation
going by passing these arguments:

- the session which should be used.
- the URI and the depth of the operation (0, 1, infinite)
- the names of the properties which you want to fetch
- a results callback, and the userdata for the callback.

For each resource found, the results callback is called, passing
you two things along with the userdata you passed in originally:

- the URI of the resource (const char *href)
- the properties results set (const dav_prop_result_set *results)





=back


=back

=head2 const http_status * = $propset -> status (propname)

Returns the status structure for fetching the given property on
this resource. This function will return NULL if the server did not
return the property (which is a server error). 

=over 4

=item Arguments

=over 4

=item $propset

const dav_prop_result_set *

The 'dav_simple_propfind' interface. ***

dav_simple_propfind allows you to fetch a set of properties for a
single resource, or a tree of resources.  You set the operation
going by passing these arguments:

- the session which should be used.
- the URI and the depth of the operation (0, 1, infinite)
- the names of the properties which you want to fetch
- a results callback, and the userdata for the callback.

For each resource found, the results callback is called, passing
you two things along with the userdata you passed in originally:

- the URI of the resource (const char *href)
- the properties results set (const dav_prop_result_set *results)



=item propname

const dav_propname *




propname = {
nspace => <string>, name => <string>, };





=back


=back

=head2 const char * = $propset -> value (propname)

Get the value of a given property. Will return NULL if there was an
error fetching this property on this resource.  Call
dav_propset_result to get the response-status if so.  

=over 4

=item Arguments

=over 4

=item $propset

const dav_prop_result_set *

The 'dav_simple_propfind' interface. ***

dav_simple_propfind allows you to fetch a set of properties for a
single resource, or a tree of resources.  You set the operation
going by passing these arguments:

- the session which should be used.
- the URI and the depth of the operation (0, 1, infinite)
- the names of the properties which you want to fetch
- a results callback, and the userdata for the callback.

For each resource found, the results callback is called, passing
you two things along with the userdata you passed in originally:

- the URI of the resource (const char *href)
- the properties results set (const dav_prop_result_set *results)



=item propname

const dav_propname *




propname = {
nspace => <string>, name => <string>, };





=back


=back



=head1 Methods of Net::Webdav::Request

=head2 $request -> add_request_header (name,value)

Adds a header to the request with given name and value. 

=over 4

=item Arguments

=over 4

=item $request

http_req *



=item name

<string>


=item value

<string>




=back


=back

=head2 $request -> add_response_body_reader (accpt,rdr)

Add a response reader for the given request, with the given
acceptance function. userdata is passed as the first argument to
the acceptance + reader callbacks. 

=over 4

=item Arguments

=over 4

=item $request

http_req *





=item Callback function: accpt

int = accpt (userdata,$request,st)

'acceptance' callback type. Return non-zero to accept the response,
else zero to ignore it. 



=over 4

=item userdata

void *

=item req

http_req *

=item st

http_status *



=back



=item Callback function: rdr

rdr (userdata,buf,len)

The 'reader' callback type 



=over 4

=item userdata

void *

=item buf

<string>

=item len

size_t



=back



=back


=back

=head2 $request -> add_response_header_catcher (hdl)

Add handler which is passed ALL header values regardless of name 

=over 4

=item Arguments

=over 4

=item $request

http_req *





=item Callback function: hdl

hdl (userdata,value)

The header handler callback type 



=over 4

=item userdata

void *

=item value

<string>



=back



=back


=back

=head2 $request -> add_response_header_handler (name,hdl)

Adds a response header handler for the given request. userdata is passed
as the first argument to the header handler, and the 'value' is the
header field value (i.e. doesn't include the "Header-Name: " part").


=over 4

=item Arguments

=over 4

=item $request

http_req *



=item name

<string>




=item Callback function: hdl

hdl (userdata,value)

The header handler callback type 



=over 4

=item userdata

void *

=item value

<string>



=back



=back


=back

=head2 int = $request -> begin_request ()


=over 4

=item Arguments

=over 4

=item $request

http_req *





=back


=back

=head2 $request -> dav_add_depth_header (depth)

Adds a Depth: header to a request 

=over 4

=item Arguments

=over 4

=item $request

http_req *



=item depth

<integer>




=back


=back

=head2 $request -> dav_lock_using_parent (uri)

Indicate that this request will modify parent collection of given URI 

=over 4

=item Arguments

=over 4

=item $request

http_req *



=item uri

<string>




=back


=back

=head2 $request -> dav_lock_using_resource (uri,depth)

Indicate that this request is of depth n on given uri 

=over 4

=item Arguments

=over 4

=item $request

http_req *



=item uri

<string>


=item depth

<integer>




=back


=back

=head2 int = $request -> end_request ()


=over 4

=item Arguments

=over 4

=item $request

http_req *





=back


=back

=head2 sbuffer = $request -> get_request_headers ()


=over 4

=item Arguments

=over 4

=item $request

http_req *





=back


=back

=head2 const http_status * = $request -> get_status ()


=over 4

=item Arguments

=over 4

=item $request

http_req *





=back


=back

=head2 ssize_t = $request -> read_response_block (buffer,buflen)


=over 4

=item Arguments

=over 4

=item $request

http_req *



=item buffer

<string>


=item buflen

size_t





=back


=back

=head2 $request -> request_destroy ()

Destroy memory associated with request pointer 

=over 4

=item Arguments

=over 4

=item $request

http_req *





=back


=back

=head2 int = $request -> request_dispatch ()

http_request_dispatch: Sends the given request, and reads the
response. Response-Status information can be retrieve with
http_get_status(req).

Returns:
HTTP_OK         if request sent + response read okay.
HTTP_AUTH       if user authentication failed on origin server
HTTP_AUTHPROXY  if user authentication failed on proxy server
HTTP_SERVERAUTH server authentication failed
HTTP_PROXYAUTH  proxy authentication failed
HTTP_CONNECT    could not connect to server/proxy server
HTTP_TIMEOUT    connection timed out mid-request
HTTP_ERROR      for other errors, and http_get_error() should
return a meaningful error string

NB: HTTP_AUTH and HTTP_AUTHPROXY mean that the USER supplied the
wrong username/password.  SERVER/PROXYAUTH mean that, after the
server has accepted a valid username/password, the server/proxy did
not authenticate the response message correctly.


=over 4

=item Arguments

=over 4

=item $request

http_req *





=back


=back

=head2 void * = $request -> request_hook_private (id)

Return private data for a new request  

=over 4

=item Arguments

=over 4

=item $request

http_req *



=item id

<string>




=back


=back

=head2 $request -> set_request_body_buffer (buffer,size)

'buffer' will be sent as the request body with given request. 

=over 4

=item Arguments

=over 4

=item $request

http_req *



=item buffer

<string>


=item size

size_t





=back


=back

=head2 $request -> set_request_body_provider (size,provider)

Callback is called to provide blocks of request body. 

=over 4

=item Arguments

=over 4

=item $request

http_req *



=item size

size_t





=item Callback function: provider

size_t = provider (userdata,buffer,buflen)

Callback for providing request body blocks.

Before each time the body is provided, the callback will be called
once with buflen == 0.  The body may have to be provided >1 time
per request (for authentication retries etc.).

Must return:
0 < x <= buflen  => buffer contains x bytes of body data.
or  0 => ignore 'buffer' contents, end of body.




=over 4

=item userdata

void *

=item buffer

<string>

=item buflen

size_t



=back



=back


=back

=head2 int = $request -> set_request_body_stream (stream)

Contents of stream will be sent as the request body with the given
request. Returns:
0 on okay.
non-zero if could not determine length of file.


=over 4

=item Arguments

=over 4

=item $request

http_req *



=item stream

<filehandle>





=back


=back



=head1 Methods of Net::Webdav::SSL

=head2 $ssl -> destroy_ssl_context ()


=over 4

=item Arguments

=over 4

=item $ssl

nssl_context *





=back


=back

=head2 $ssl -> disable_sslv2 ()


=over 4

=item Arguments

=over 4

=item $ssl

nssl_context *





=back


=back

=head2 $ssl -> disable_sslv3 ()


=over 4

=item Arguments

=over 4

=item $ssl

nssl_context *





=back


=back

=head2 $ssl -> disable_tlsv1 ()


=over 4

=item Arguments

=over 4

=item $ssl

nssl_context *





=back


=back

=head2 $ssl -> set_cert_accept (accepter)


=over 4

=item Arguments

=over 4

=item $ssl

nssl_context *





=item Callback function: accepter

int = accepter (userdata,info)

Returns:
0 -> User accepts the certificate
non-zero -> user does NOT accept the certificate.




=over 4

=item userdata

void *

=item info

const nssl_certificate *



=back



=back


=back

=head2 int = $ssl -> set_client_cert (certfile,keyfile)

For PEM-encoded client certificates: use the given client
certificate and private key file. 
Returns: 0 if certificate is read okay,
non-zero otherwise.

For decoding the private key file, the callback above will be used
to prompt for the password.  If no callback has been set, then the
OpenSSL default will be used: the prompt appears on the terminal.


=over 4

=item Arguments

=over 4

=item $ssl

nssl_context *



=item certfile

<string>


=item keyfile

<string>




=back


=back

=head2 $ssl -> set_key_prompt (prompt)


=over 4

=item Arguments

=over 4

=item $ssl

nssl_context *





=item Callback function: prompt

int = prompt (userdata,filename,buf,buflen)

Callback for retrieving the private key password.
Filename will be the filename of the private key file.
Must return:
0 on success.  buf must be filled in with the password.
non-zero if the user cancelled the prompt.

FIXME: this is inconsistent with the HTTP authentication callbacks.  



=over 4

=item userdata

void *

=item filename

<string>

=item buf

<string>

=item buflen

<integer>



=back



=back


=back



=head1 Methods of Net::Webdav::Socket

=head2 int = $socket -> block (timeout)

Blocks waiting for data on the given socket for the given time.
Returns:
SOCK_* on error,
SOCK_TIMEOUT on no data within timeout,
0 if data arrived on the socket.


=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item timeout

<integer>




=back


=back

=head2 $socket -> call_progress (progress,total)


=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item progress

<integer>



=item total

<integer>





=back


=back

=head2 int = $socket -> close ()

Closes the socket and frees the nsocket object. 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *





=back


=back

=head2 int = $socket -> fullread (buffer,buflen)

Reads a chunk of data. 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item buffer

<string>


=item buflen

<integer>




=back


=back

=head2 int = $socket -> fullwrite (data,length)

Sends the given block of data down the nsocket 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item data

<string>


=item length

size_t





=back


=back

=head2 const char * = $socket -> get_error ()


=over 4

=item Arguments

=over 4

=item $socket

nsocket *





=back


=back

=head2 int = $socket -> get_fd ()

Returns the file descriptor used for the socket 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *





=back


=back

=head2 const char * = $socket -> get_version ()


=over 4

=item Arguments

=over 4

=item $socket

nsocket *





=back


=back

=head2 int = $socket -> make_secure ($ssl)

Ctx is OPTIONAL. If it is NULL, defaults are used. 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item $ssl

nssl_context *





=back


=back

=head2 int = $socket -> peek (buffer,count)

sock_peek is recv() with a timeout of SOCKET_TIMEOUT.
Returns:
SOCK_* on error,
0 on no data to read (due to EOF),
>0 length of data read into buffer.


=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item buffer

<string>


=item count

size_t





=back


=back

=head2 int = $socket -> read (buffer,count)

sock_read is read() with a timeout of SOCKET_TIMEOUT.
Returns:
SOCK_* on error,
0 on no data to read (due to EOF),
>0 length of data read into buffer.


=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item buffer

<string>


=item count

size_t





=back


=back

=head2 int = $socket -> readfile_blocked (length,reader)

Read from socket, passing each block read to reader callback.
Pass userdata as first argument to reader callback.

If length is -1, keep going till EOF is returned. SOCK_CLOSED
is never returned in this case.

Otherwise, read exactly 'length' bytes. If EOF is encountered
before length bytes have been read, and SOCK_CLOSED will be
returned.

Returns:
0 on success,
SOCK_* on error (SOCK_CLOSED is a special case, as above)


=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item length

<integer>





=item Callback function: reader

reader (userdata,buf,len)




=over 4

=item userdata

void *

=item buf

<string>

=item len

size_t



=back



=back


=back

=head2 int = $socket -> readline (line,len)

Reads a line from given nsocket 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item line

<string>


=item len

<integer>




=back


=back

=head2 $socket -> register_progress (cb)


=over 4

=item Arguments

=over 4

=item $socket

nsocket *





=item Callback function: cb

cb (userdata,progress,total)




=over 4

=item userdata

void *

=item progress

<integer>

=item total

<integer>



=back



=back


=back

=head2 int = $socket -> send_string (string)

Sends the null-terminated string down the given nsocket 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item string

<string>




=back


=back

=head2 int = $socket -> sendline (line)

Sends the given line to given socket, CRLF appended 

=over 4

=item Arguments

=over 4

=item $socket

nsocket *



=item line

<string>




=back


=back



=head1 Methods of Net::Webdav::Util

=head2 int = Net::Webdav::Util::dav_accept_207 (userdata,$request,status)

An acceptance function which only accepts 207 responses 

=over 4

=item Arguments

=over 4

=item userdata

void *


=item $request

http_req *



=item status

http_status *




status = {
major_version => <integer>, minor_version => <integer>, code => <integer>, klass => <integer>, reason_phrase => <string>, };





=back


=back

=head2 $hip = Net::Webdav::Util::hip_xml_create ()

Initialise the parser 

=over 4

=item Arguments

=over 4



=back


=back

=head2 Net::Webdav::Util::hip_xml_parse_v (userdata,block,len)

As above, casting (hip_xml_parser *)userdata internally.
(This function can be passed to http_add_response_body_reader) 

=over 4

=item Arguments

=over 4

=item userdata

void *


=item block

<string>


=item len

size_t





=back


=back

=head2 int = Net::Webdav::Util::http_accept_2xx (userdata,$request,st)

An 'acceptance' callback which only accepts 2xx-class responses.
Ignores userdata. 

=over 4

=item Arguments

=over 4

=item userdata

void *


=item $request

http_req *



=item st

http_status *




st = {
major_version => <integer>, minor_version => <integer>, code => <integer>, klass => <integer>, reason_phrase => <string>, };





=back


=back

=head2 int = Net::Webdav::Util::http_accept_always (userdata,$request,st)

An acceptance callback which accepts all responses.  Ignores
userdata. 

=over 4

=item Arguments

=over 4

=item userdata

void *


=item $request

http_req *



=item st

http_status *




st = {
major_version => <integer>, minor_version => <integer>, code => <integer>, klass => <integer>, reason_phrase => <string>, };





=back


=back

=head2 Net::Webdav::Util::http_content_type_handler (userdata,value)

Sets (*http_content_type)userdata appropriately. 
Caller must free ->value after use 

=over 4

=item Arguments

=over 4

=item userdata

void *


=item value

<string>




=back


=back

=head2 time_t = Net::Webdav::Util::http_dateparse (date)


=over 4

=item Arguments

=over 4

=item date

<string>




=back


=back

=head2 Net::Webdav::Util::http_duplicate_header (userdata,value)

Stock header handlers:
'duplicate': *(char **)userdata = strdup(value)
'numeric':   *(int *)userdata = atoi(value)
e.g.
int mynum;
http_add_response_header_handler(myreq, "Content-Length",
http_handle_numeric_handler, &mynum);
... arranges mynum to be set to the value of the Content-Length header.


=over 4

=item Arguments

=over 4

=item userdata

void *


=item value

<string>




=back


=back

=head2 Net::Webdav::Util::http_handle_numeric_header (userdata,value)


=over 4

=item Arguments

=over 4

=item userdata

void *


=item value

<string>




=back


=back

=head2 int = Net::Webdav::Util::http_parse_statusline (status_line,s)

Parser for strings which follow the Status-Line grammar from 
RFC2616.
Returns:
0 on success, *s will be filled in.
-1 on parse error.


=over 4

=item Arguments

=over 4

=item status_line

<string>


=item s

http_status *




s = {
major_version => <integer>, minor_version => <integer>, code => <integer>, klass => <integer>, reason_phrase => <string>, };





=back


=back

=head2 $session = Net::Webdav::Util::http_session_create ()

Create a new HTTP session 

=over 4

=item Arguments

=over 4



=back


=back

=head2 time_t = Net::Webdav::Util::ne_asctime_parse (date)

Parses asctime date string 

=over 4

=item Arguments

=over 4

=item date

<string>




=back


=back

=head2 void * = Net::Webdav::Util::ne_calloc (len)


=over 4

=item Arguments

=over 4

=item len

size_t





=back


=back

=head2 void * = Net::Webdav::Util::ne_md5_buffer (buffer,len,resblock)


=over 4

=item Arguments

=over 4

=item buffer

<string>


=item len

size_t



=item resblock

void *




=back


=back

=head2 Net::Webdav::Util::ne_md5_process_block (buffer,len,$md5ctx)


=over 4

=item Arguments

=over 4

=item buffer

const void *


=item len

size_t



=item $md5ctx

struct ne_md5_ctx *




=back


=back

=head2 Net::Webdav::Util::ne_md5_process_bytes (buffer,len,$md5ctx)


=over 4

=item Arguments

=over 4

=item buffer

const void *


=item len

size_t



=item $md5ctx

struct ne_md5_ctx *




=back


=back

=head2 void * = Net::Webdav::Util::ne_md5_read_ctx (ctx,resbuf)


=over 4

=item Arguments

=over 4

=item ctx

const struct ne_md5_ctx *


=item resbuf

void *




=back


=back

=head2 int = Net::Webdav::Util::ne_md5_stream (stream,resblock)


=over 4

=item Arguments

=over 4

=item stream

<filehandle>



=item resblock

void *




=back


=back

=head2 void * = Net::Webdav::Util::ne_realloc (ptr,len)


=over 4

=item Arguments

=over 4

=item ptr

void *


=item len

size_t





=back


=back

=head2 time_t = Net::Webdav::Util::ne_rfc1036_parse (date)


=over 4

=item Arguments

=over 4

=item date

<string>




=back


=back

=head2 char * = Net::Webdav::Util::ne_rfc1123_date (anytime)

Return current date/time in RFC1123 format 

=over 4

=item Arguments

=over 4

=item anytime

time_t





=back


=back

=head2 time_t = Net::Webdav::Util::ne_rfc1123_parse (date)

Returns time from date/time in RFC1123 format 

=over 4

=item Arguments

=over 4

=item date

<string>




=back


=back

=head2 char * = Net::Webdav::Util::ne_strdup (s)


=over 4

=item Arguments

=over 4

=item s

<string>




=back


=back

=head2 char * = Net::Webdav::Util::ne_strndup (s,n)


=over 4

=item Arguments

=over 4

=item s

<string>


=item n

size_t





=back


=back

=head2 char * = Net::Webdav::Util::ne_utf8_decode (str)

Returns an ne_malloc-allocated UTF-8 decode copy of 'str'.
Returns NULL if any of the characters in 'str' are non-8-bit.


=over 4

=item Arguments

=over 4

=item str

<string>




=back


=back

=head2 char * = Net::Webdav::Util::ne_utf8_encode (str)

Returns an ne_malloc-allocated UTF-8 encoded copy of 'str'. 

=over 4

=item Arguments

=over 4

=item str

<string>




=back


=back

=head2 Net::Webdav::Util::neon_debug_init (stream,mask)


=over 4

=item Arguments

=over 4

=item stream

<filehandle>



=item mask

<integer>




=back


=back

=head2 Net::Webdav::Util::neon_i18n_init ()

Initialize i18n in neon 

=over 4

=item Arguments

=over 4



=back


=back

=head2 int = Net::Webdav::Util::neon_version_minimum (major,minor)

Returns non-zero if the neon API compiled in is less than
major.minor. i.e.
I am: 1.2 -  neon_version_check(1, 3) => -1
I am: 0.10 -  neon_version_check(0, 9) => 0


=over 4

=item Arguments

=over 4

=item major

<integer>


=item minor

<integer>




=back


=back

=head2 const char * = Net::Webdav::Util::neon_version_string ()

Returns a user-visible version string like:
"neon 0.2.0: Standalone build, OpenSSL support"


=over 4

=item Arguments

=over 4



=back


=back

=head2 Net::Webdav::Util::sbuffer_altered (buf)


=over 4

=item Arguments

=over 4

=item buf

sbuffer





=back


=back

=head2 int = Net::Webdav::Util::sbuffer_append (buf,data,len)

Append 'len' bytes of 'data' to buf.  'data' does not need to be
zero-terminated. The resultant string will have a zero-terminator,
either way. Returns 0 on success, non-zero on error.  

=over 4

=item Arguments

=over 4

=item buf

sbuffer



=item data

<string>


=item len

size_t





=back


=back

=head2 Net::Webdav::Util::sbuffer_clear (buf)

Empties the contents of buf; makes the buffer zero-length. 

=over 4

=item Arguments

=over 4

=item buf

sbuffer





=back


=back

=head2 sbuffer = Net::Webdav::Util::sbuffer_create ()

Create a new sbuffer. Returns NULL on error 

=over 4

=item Arguments

=over 4



=back


=back

=head2 sbuffer = Net::Webdav::Util::sbuffer_create_sized (size)

Create a new sbuffer of given minimum size. Returns NULL on error 

=over 4

=item Arguments

=over 4

=item size

size_t





=back


=back

=head2 char * = Net::Webdav::Util::sbuffer_data (buf)

Returns contents of buffer at current point in time.
NOTE: if the buffer is modified with _concat, _append etc,
this value may no longer be correct. 

=over 4

=item Arguments

=over 4

=item buf

sbuffer





=back


=back

=head2 Net::Webdav::Util::sbuffer_destroy (buf)

Destroys (deallocates) a buffer 

=over 4

=item Arguments

=over 4

=item buf

sbuffer





=back


=back

=head2 char * = Net::Webdav::Util::sbuffer_finish (buf)

Destroys a buffer, WITHOUT freeing the data, and returns the
data. 

=over 4

=item Arguments

=over 4

=item buf

sbuffer





=back


=back

=head2 int = Net::Webdav::Util::sbuffer_grow (buf,size)

Grows the sbuffer to a minimum size.
Returns 0 on success, non-zero on error 

=over 4

=item Arguments

=over 4

=item buf

sbuffer



=item size

size_t





=back


=back

=head2 int = Net::Webdav::Util::sbuffer_size (buf)

Returns size of data in buffer, equiv to strlen(sbuffer_data(buf)) 

=over 4

=item Arguments

=over 4

=item buf

sbuffer





=back


=back

=head2 int = Net::Webdav::Util::sbuffer_zappend (buf,str)

Append a zero-terminated string 'str' to buf.
Returns 0 on success, non-zero on error. 

=over 4

=item Arguments

=over 4

=item buf

sbuffer



=item str

<string>




=back


=back

=head2 $socket = Net::Webdav::Util::sock_accept (listener)

Not as good as accept(2), missing parms 2+3.
Addings parms 2+3 would probably mean passing socklen_t as an
int then casting internally, since we don't really want to
autogenerate the header file to be correct for the build platform.


=over 4

=item Arguments

=over 4

=item listener

<integer>




=back


=back

=head2 $ssl = Net::Webdav::Util::sock_create_ssl_context ()

Netscape's prompts on getting a certificate which it doesn't
recognize the CA for:
1. Hey, I don't recognize the CA for this cert.
2. Here is the certificate: for foo signed by BLAH,
using encryption level BLEE
3. Allow: accept for this session only, 
don't accept
accept forever


=over 4

=item Arguments

=over 4



=back


=back

=head2 Net::Webdav::Util::sock_exit ()

Shutdown the socket library. 

=over 4

=item Arguments

=over 4



=back


=back

=head2 int = Net::Webdav::Util::sock_init ()

Initialize the socket library. If you don't do this, SSL WILL NOT WORK.
Returns 0 on success, or non-zero on screwed up SSL library. 

=over 4

=item Arguments

=over 4



=back


=back

=head2 int = Net::Webdav::Util::sock_name_lookup (hostname,addr)

Do a name lookup on given hostname, writes the address into
given address buffer. Return -1 on failure. 

=over 4

=item Arguments

=over 4

=item hostname

<string>


=item addr

struct in_addr *




=back


=back

=head2 int = Net::Webdav::Util::sock_service_lookup (name)

Returns the standard TCP port for the given service 

=over 4

=item Arguments

=over 4

=item name

<string>




=back


=back

=head2 int = Net::Webdav::Util::sock_transfer (fd,$socket,readlen)

Reads readlen bytes from fd and writes to socket.
(Not all in one go, obviously).
If readlen == -1, then it reads from srcfd until EOF.
Returns number of bytes written to destfd, or SOCK_* on error.


=over 4

=item Arguments

=over 4

=item fd

<integer>


=item $socket

nsocket *



=item readlen

<integer>





=back


=back

=head2 char * = Net::Webdav::Util::uri_absolute (uri,scheme,hostport)

Returns an absolute URI from a possibly-relative 'uri', using
given scheme + hostport segment.
Returns malloc-allocated string on success, or NULL on malloc failure. 

=over 4

=item Arguments

=over 4

=item uri

<string>


=item scheme

<string>


=item hostport

<string>




=back


=back

=head2 const char * = Net::Webdav::Util::uri_abspath (uri)

Returns abspath segment in (absolute) uri 

=over 4

=item Arguments

=over 4

=item uri

<string>




=back


=back

=head2 char * = Net::Webdav::Util::uri_abspath_escape (abs_path)

Escapes the abspath segment of a URI.
Returns malloc-allocated string on success, or NULL on malloc failure.


=over 4

=item Arguments

=over 4

=item abs_path

<string>




=back


=back

=head2 int = Net::Webdav::Util::uri_childof (parent,child)

Returns non-zero if child is a child of parent 

=over 4

=item Arguments

=over 4

=item parent

<string>


=item child

<string>




=back


=back

=head2 int = Net::Webdav::Util::uri_compare (a,b)

Returns strcmp-like value giving comparison between a and b,
ignoring trailing-slashes. 

=over 4

=item Arguments

=over 4

=item a

<string>


=item b

<string>




=back


=back

=head2 Net::Webdav::Util::uri_free (parsed)


=over 4

=item Arguments

=over 4

=item parsed

struct uri *




=back


=back

=head2 int = Net::Webdav::Util::uri_has_trailing_slash (uri)

Returns non-zero if uri has a trailing slash character 

=over 4

=item Arguments

=over 4

=item uri

<string>




=back


=back

=head2 char * = Net::Webdav::Util::uri_parent (path)

Returns parent of path 

=over 4

=item Arguments

=over 4

=item path

<string>




=back


=back

=head2 int = Net::Webdav::Util::uri_parse (uri,parsed,defaults)

Parse 'uri' and place parsed segments in *parsed. 

=over 4

=item Arguments

=over 4

=item uri

<string>


=item parsed

struct uri *


=item defaults

const struct uri *




=back


=back

=head2 char * = Net::Webdav::Util::uri_unescape (uri)

Un-escapes a URI. Returns malloc-allocated URI on success,
or NULL on failure (malloc failure or invalid %<HEX><HEX> sequence). 

=over 4

=item Arguments

=over 4

=item uri

<string>




=back


=back



=head1 Constants

=over 4

Constants are defined in Net::Webdav::Constants, to get them imported say

use Net::Webdav::Constants ;

=item DAV_BASIC_H



=item DAV_DEPTH_INFINITE



=item DAV_DEPTH_ONE



=item DAV_DEPTH_ZERO



=item DAV_ELM_207_UNUSED



=item DAV_ELM_207_first



=item DAV_ELM_href



=item DAV_ELM_multistatus



=item DAV_ELM_prop



=item DAV_ELM_propstat



=item DAV_ELM_response



=item DAV_ELM_responsedescription



=item DAV_ELM_status



=item DAV_LOCKS_H



=item DAV_PROPS_H



=item DAV_TIMEOUT_INFINITE



=item DAV_TIMEOUT_INVALID



=item HIP_ELM_UNUSED



=item HIP_ELM_root



=item HIP_ELM_unknown



=item HIP_XML_CDATA



=item HIP_XML_COLLECT



=item HIP_XML_DECLINE



=item HIP_XML_H



=item HIP_XML_INVALID



=item HIP_XML_MIXED



=item HIP_XML_UTF8DECODE



=item HIP_XML_VALID



=item HTTP_AUTH

 User authentication failed on proxy 

=item HTTP_AUTHPROXY

 User authentication failed on proxy 

=item HTTP_BASIC_H



=item HTTP_CONNECT

 Could not connect to server 

=item HTTP_ERROR

 Generic error; use http_get_error(session) for message 

=item HTTP_FAILED

 The precondition failed 

=item HTTP_LOOKUP

 Name lookup failed 

=item HTTP_OK



=item HTTP_PORT



=item HTTP_PROXYAUTH

 Proxy authentication failed 

=item HTTP_QUOTES



=item HTTP_REDIRECT

 See http_redirect.h 

=item HTTP_REDIRECT_H



=item HTTP_REQUEST_H



=item HTTP_RETRY

 Retry request (http_end_request ONLY) 

=item HTTP_SERVERAUTH

 Server authentication failed 

=item HTTP_TIMEOUT

 Connection timed out 

=item HTTP_UTILS_H



=item HTTP_WHITESPACE



=back
=head1 See also

http://www.webdav.org/neon/

=head1 SUPPORT

For any problems, suggestion or feedback, please use the neon mailing list

post to:    neon@webdav.org
subscribe:  http://mailman.webdav.org/mailman/listinfo/neon/

=head1 COPYRIGHT

Copyright (c) 2001 Gerald Richter / ecos gmbh (www.ecos.de)

You may distribute under the terms of either the GNU General Public 
License or the Artistic License, as specified in the Perl README file.

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED 
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.


=head1 AUTHOR

Gerald Richter / ecos <richter@dev.ecos.de>

